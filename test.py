import unittest
import re

from bs4 import BeautifulSoup

from proxy_content_handler import ProxyContentHandler

class TestProxyContentHandler(unittest.TestCase):

    contentHandler = ProxyContentHandler()

    def test_end_to_end(self):
        # Cover absolute links handling, and target text in different positions
        original = "123456"
        processed = original + self.contentHandler.TM

        remote_server = "https://some-server.com"
        path = "/path/to/somewhere"
        absolute_link = f"{remote_server}{path}"
        relative_link = f"{path}"

        html_input = f'''
            <html>
            <head>
                <title>{original}</title>
                <style type="text/css">
                {original}
                </style>
                <link rel="stylesheet" href="{absolute_link}" />
            </head>
            <body>
                <div>{original}</div>
                <script type="javascript">
                    {original}
                </script>
                <div>
                    {original}
                    <a href="{absolute_link}">{original}</a>
                    <code>{original}</code>
                </div>
                <script type="javascript" src="some_URL"></script>
                <div class="{original}">{original}</div>
                <script>
                    {original}
                </script>
            </body>
            </html>
        '''

        html_output = f'''
            <html>
            <head>
                <title>{processed}</title>
                <style type="text/css">
                {original}
                </style>
                <link rel="stylesheet" href="{relative_link}" />
            </head>
                
            <body>
                <div>{processed}</div>
                <script type="javascript">
                    {original}
                </script>
                <div>
                    {processed}
                    <a href="{relative_link}">{processed}</a>
                    <code>{original}</code>
                </div>
                <script type="javascript" src="some_URL"></script>
                <div class="{original}">{processed}</div>
                <script>
                    {original}
                </script>
            </body>
            </html>
        '''
        # Disregard formatting differences, and order of attributes generated by the parser.
        html_output = BeautifulSoup(html_output, "html.parser").encode().decode()

        actual_html_output = self.contentHandler.handle_absolute_local_links(html_input, remote_server)
        actual_html_output = self.contentHandler.\
            handle_textual_content(actual_html_output).\
            decode()

        self.assertEqual(actual_html_output, html_output)

    def test_handle_textual_content_fail(self):
        # Check that handle_textual_content fails with a non string argument.
        with self.assertRaises(TypeError):
            self.contentHandler.handle_textual_content(b'')

    def test_renderable_text_re(self):
        # Cover matching renderable strings in different positions.
        html_input = f'''
            <html>
            <head>
                <title>text1</title>
                <style type="text/css">
                    /* text2 */
                </style>
            </head>
            <body>
                <div>text3</div>
                <script type="javascript">
                    /* text4 */
                </script>
                <div>
                    text5
                    <a href="someURL">text6</a>
                    text7
                </div>
            </body>
            </html>
        '''
        matches = self.contentHandler.renderable_text_re.findall(html_input)
        # Account for empty or newline matches.
        empties = re.findall(r"(?miux)>\s+?<", html_input)
        self.assertEqual(len(matches), 7 + len(empties))

    def test_non_textual_tags_re_with_soup(self):
        html_input = f'''
            <html>
            <head>
                <title>not match</title>
            </head>
            <body>
                <div>no match</div>
                <script type="javascript">
                    /* MATCH1 */
                </script>
                <style type="text/css">
                    /* MATCH2 */
                </style>
                <svg>
                    MATCH3
                    <path>MATCH4</path>
                </svg>
                <code>MATCH5</code>
                <script type="javascript">
                    /* MATCH6 */
                </script>
            </body>
            </html>
        '''

        soup = BeautifulSoup(html_input, "html.parser")
        matches = soup.find_all(self.contentHandler.non_textual_tags_re)
        self.assertEqual(len(matches), 6)

    def test_six_character_words_re(self):
        # Should match a six-char word regardless of case, language or position
        text_input = '''
        Сейчас на фоне уязвимости Logjam все в индустрии в очередной раз обсуждают 
проблемы и особенности TLS. Я хочу воспользоваться этой возможностью, чтобы 
поговорить об одной из них, а именно — о настройке ciphersiutes.
        '''
        matches = self.contentHandler.six_character_words_re.findall(text_input)
        self.assertEqual(len(matches), 3)


if __name__ == '__main__':
    unittest.main()
